- 零零碎碎的记一些知识点，主要针对我不知道的一些坑点，甚至不能算大纲，想要侧重复习请参照[某位大佬的考试总结](https://hyiker.com/2020/12/24/CSAPP%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/)，里面有往年大致题型和重要程度的标星。

- C语言按位（位级）运算符（主要是想打表格玩玩，然后注意一下异或符号）

|~| |
|---|---|
|0|1|
|1|0|

|&|0|1|
|--|-|-|
|0|0| 0|
|1|0| 1|

|&#124;|0|1|
|--|--|--|
|0|0|1|
|1|1|1|

|<mark>^</mark>|0|1|
|--|--|--|
|0|0|1|
|1|1|0|

- 字长（wordsize）：指明指针数据的标称大小（normalsize）。字长决定的最重要的系统参数就是虚拟地址空间的最大大小。32位字：4GB；64位字：16EB；

- 但是在汇编mov语句中(比如movb，包括r8~r15的寄存器命名中，e.g.r8的低32位就用r8d表示，低16位用r8w表示,低8位用r8b表示)，由于是**从16位体系结构扩展成32位**(这里的字并不是真正的字，而是指的16位机器的字)的，Intel用术语“字(word)”表示16位数据类型，因此称32(d或l(x86的long word是32位,但x86-64的long是64位的)位为double words,64(q)位为quad words,而八位就用(b)byte表示。

- int32_t和int64_t是ISO C99引入的固定大小的数据类型，分别是4和8个字节。但是int在32位和64位都是4字节。

- size_t:一种数据类型，在表示数据结构大小的时候首选使用。

- **加减法的算术优先级高于移位运算**，故1<<2+3<<4实际上是1<<(2+3)<<4

- leaq不改变条件码！！

- movz：零扩展；movs：有符号扩展；

![寻址](https://api2.mubu.com/v3/document_image/e841e256-f1cb-4401-b850-608d5836e0bb-15867716.jpg)

- ↑比例变址寻址时候，比例因子s只能是1，2，4，8.

![整数的算数运算术语/函数](https://api2.mubu.com/v3/document_image/cbce1006-67eb-47d8-bfd9-632646c15130-15867716.jpg)

![重要的数字](https://api2.mubu.com/v3/document_image/4c683f3e-d08c-4442-a3f7-5dae4dc5f434-15867716.jpg)

- strlen的函数声明为：size_t strlen(const char* s);其中**size_t**是**unsigned**的，当返回值是int类型并且返回一个strlen(s1)-strlen(s2)(或者别的什么)时，就会出现错误。

- .o文件的所有定义是全部进D的,但是.a文件中的定义不是，只有未被解析而定义在.a文件中的是会进D的,所以.o文件只要在前面一次就够,但.a可能需要多次。

- 反汇编列表中给出的重定位引用的值是用小端法字节顺序表示的，而且差值的计算要从当前语句的下一个开始计算，这是因为执行到这个语句的时候程序计数器PC已(%rip)经自动加到指向下一个语句了:)，毕竟，程序计数器的定义就是：（通常称为PC，在x86-64中用%rip表示）给出将要执行的下一条指令在内存中的地址。

- 汇编代码不区分有符号或无符号整数，不区分各种类型的指针，甚至于不区分指针和整数，不区分各种类型的指针，甚至于不区分指针和数组。

- 程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块（比如malloc分配的）

- 关于gcc的一些参数
  - -Og:生成符合原始C代码整体结构的机器代码的优化等级，较高优化等级的参数有：-O1,-O2,-OS等等。
  - -c:GCC会编译并汇编该代码。生成.o文件(可重定位目标文件relocatable object file)
  - -s生成汇编文件。

- 关于寄存器，可以记一下这张图,字丑，但是重点基本都在

![jicunqi](https://api2.mubu.com/v3/document_image/4545aa64-9821-46c6-a4aa-c98df511b51d-15867716.jpg)

- 关于条件码

![条件码](https://api2.mubu.com/v3/document_image/01a3801e-32b3-4058-ad27-602a07e2306d-15867716.jpg)

- cmp指令和test指令
  这俩指令都只改变条件码，但是不储存原本的计算结果，其中cmp a b等价于b-a，和sub的行为一样，test和and的行为一样，test和xor指令常常用来置标志位。

- 计算同一个数据节构中的两个指针之差，结果的**数据类型为long**,值等于两个地址之差除以该数据类型的大小。

- 异常
![](https://api2.mubu.com/v3/document_image/e7132f03-56b5-434d-91cc-5bdbacf2b57b-15867716.jpg)

- 关于EOF
![](https://api2.mubu.com/v3/document_image/72b05417-ac6c-4456-9ccf-1d6bcdb06515-15867716.jpg)

## www感觉自己太摸了所以系统整理一下I/O

### 10.1-10.4提纲

![大纲](https://api2.mubu.com/v3/document_image/2952bc4a-00d4-4b57-b8e3-feab4c5046a8-15867716.jpg)
- details:
1. open函数的定义和flag参数说明
   int open(char *filename,int flags,mode_t mode);
   flag参数：
  ![open的三个参数](https://api2.mubu.com/v3/document_image/98db7495-cd74-4e2d-b0eb-78678e6ed57b-15867716.jpg)
  open函数的声明和返回值(返回文件描述符，且**返回的描述符总是在进程中当前没有打开的最小描述符**，出错返-1
2. read函数的定义：ssize_t read(int fd,void* buf,size_t n);
3. write函数的定义：ssize_t write(int fd,const void *buf,size_t n);注意，ssize_t是long类型，size_t是unsigned类型，因为read函数要返回-1:)
4. 关闭一个已关闭的描述符会出错。
5. read函数在遇到eof时下一个read以返回值不足0来反映EOF信号。
6. 从终端读取文本行时，read函数将会一次传送一个文本行。
7. 用RIO包健壮的写，练习题都没得，估计也不重要，skip了。

### 10.6，10.7





练习题
第2章
2.21、2.23、2.24、2.33、2.40、2.45、2.47、2.54
2.60、2.65、2.67、2.68

第3章
3.1、3.2、3.3、3.4（先阅读图3-5、3-6指令功能）、3.5、3.6
3.7、3.9、3.15、3.18、3.20、3.26、3.27、3.31、3.32、3.33
3.36、3.37、3.38、3.44、3.45

第7章
7.1、7.2、7.4、7.5

第10章
10.1、10.2、10.3、10.5